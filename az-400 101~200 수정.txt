101. 3-1-2> 3-2-1
• '위협 모델링'은 일반적으로 수동 프로세스이며 PR 검토의 일부로 수행됨
• '정적 코드'는 sonarqube와 같은 도구를 사용하여 빌드 단계에서 수행
• '침투 테스트'는 코드가 빌드되고 배포 준비가 되면 웹 공격이 없는지 확인함
======================= topic 4 : QuestionSet 4 =======================
102. C > D
• Project 생성 후 Repos/Files 내부에 Repository 가져오기
• GitHub, Bitbucket, GitLab, 기타 위치의 기존 Git 리포지토리를 Azure DevOps의 프로젝트에 있는 새 리포지토리 또는 비어 있는 리포지토리로 가져올 수 있음

103. B
• 기술 부채는 애플리케이션 수명 동안 내린 차선의 기술적 결정의 누적
> 코드 중복을 늘리는 것보다 코드의 복잡성을 줄이는게 좋음
104. B
• 프로젝트에 더 많은 테스트 커버리지를 추가한다고 해서 기술 부채가 해결되지는 않음
105. A
• 코드 복잡성을 줄이면 개발자의 시간이 절약됨

106. B
• PMD는 소스 코드 분석기로 사용하지 않는 변수, 빈 catch 블록, 불필요한 개체 생성 등과 같은 일반적인 프로그래밍 결함을 찾음
• 프로젝트의 소스 코드에서 PMD 코드 분석 도구를 자동으로 실행하고 결과가 포함된 사이트 보고서를 생성할 수 있는 Apache Maven PMD 플러그인이 있음
B : xcpretty는 xcodebuild를 위한 빠르고 유연한 포맷터

107. C > B
https://docs.microsoft.com/ko-kr/azure/devops/artifacts/tutorials/share-packages-publicly?view=azure-devops
• Azure Artifacts는 공용 피드를 사용하여 조직 외부의 사용자에게 패키지를 공유하는 쉬운 방법을 제공하여 공유 피드에 저장된 패키지는 인터넷의 모든 사용자가 복원,설치,사용할 수 있음
☞ 공용 피드를 사용하기 위해 먼저 공개 피드를 생성하고 패키지를 채워 넣음

108. C
• SonarCloud는 SonarSource에서 제공하고 SonarQube를 기반으로 하는 클라우드 서비스로 20 이상의 다른 언어로 소스 코드의 품질을 지속적으로 검사하고 버그, 취약성 및 코드 오류를 감지하기 위해 널리 채택된 오픈 소스 플랫폼
☞ SonarCloud Azure DevOps 확장은 SonarCloud에서 프로젝트를 매우 빠르게 분석하는 데 필요한 모든 것을 제공함
A : 테스트 계획은 테스트 스위트와 개별 테스트 케이스를 함께 그룹화하는데 사용됨

109. B>A (103~105번과 같은 시나리오)
• 커플링 코드를 줄이므로 코드의 복잡성을 줄이는 데 도움이됨

110. B,C
• SonarQube 사정 승인을 통해 품질 게이트를 설정할 수 있음

111. A
• SonarQube 빌드를 실행하기 필요한 모든 설정을 구성하려면 분석 구성 준비 작업을 수행함
☞ 필수인 작업으로 .Net 솔루션 또는 Java 프로젝트의 경우 MSBulid, Maven 및 Gradle 작업과 원활하게 통합하는 데 도움이 됨.

112. C
• SonarQube 빌드를 실행하기 필요한 모든 설정을 구성하려면 분석 구성 준비 작업을 수행함
☞ 필수인 작업으로 .Net 솔루션 또는 Java 프로젝트의 경우 MSBulid, Maven 및 Gradle 작업과 원활하게 통합하는 데 도움이 됨.

113. 3-5-2-4 > 5-4-2-1
• 먼저 SonarCloud에 대한 분석 구성을 준비하고 Visual Studio로 .Net 프로젝트를 빌드하고 테스트를 진행, 마지막으로 SonarCloud 도구를 사용하여 코드 분석을 실행함
구성 > 빌드 > 테스트 > 분석

114. B
기술 부채 관리 전략 .. > SonarQube 사용

115. 3-1-2
https://docs.microsoft.com/ko-kr/azure/devops/artifacts/collaborate-with-packages?view=azure-devops
• 코드 베이스에 대한 올바른 기능을 결정하려면 제품의 종속성 그래프를 그린 다음 구성 요소를 관련 구성 요소 집합으로 그룹화하기 시작
1) 작업 항목과 기타 개체를 연결하여 관련 작업, 종속성 및 시간 경과에 따른 변경 사항을 추적하기 위해 '응용 프로그램에 대한 종속성 그래프를 만들기'
2) 패키지를 사용하면 조직 전체에서 코드를 공유하고 대규모 작품을 작성하거나 공통 공유 프레임워크를 기반으로 여러 제품을 개발하거나 재사용 가능한 구성 요소와 라이브러리를 만들고 공유할 수 있기 때문에 '관련 구성요소(Component)를 그룹화함'
3) 각 구성 요소 그래프에 대한 소유권을 할당

116. 1-3-5-4 > 1-5-3-4
https://docs.microsoft.com/ko-kr/azure/devops/artifacts/get-started-nuget?view=azure-devops&tabs=windows#create-a-feed
피드 생성 > 패키지 배포 > 피드 연결 > 패키지 설치
1) 피드 생성 - MS는 비공개 NuGet 피드를 게시하고 관리하기 위한 공식 확장을 제공
2) 패키지 배포 - 빌드된 프로젝트를 NuGet 피드에 게시, 압축, 푸시
3) 피드 연결 - 패키지를 사용할 수 있으므로 Visual Studio에서 피드를 연결하고 패키지 다운로드


117. B
정확한 코드 분석을 위해 PMD 및 Findbugs를 사용할 수 있음

118. A,B,E
B > A > E
1) Azure DevOps 인스턴스 내에서 사용자 지정 NuGet 패키지 피드를 사용하면 조직 내에서 쉽게 패키지를 배포할 수 있음(B)
2) 빌드된 프로젝트를 NuGet 피드에 게시, 패키징 및 푸시할 수 있음(A)
3) Azure DevOps의 패키지 영역으로 돌아가서 피드를 선택하고 '피드에 연결' 설정에서 패키지 소스 URL을 복사하고 NuGet 패키지 관리자를 열고 설정으로 이동하여 소스를 추가(E)
* NuGet 패키지는 Visual Studio에서 개발 확장으로 공개한 무료 오픈 소스 패키지 관리자 프로그램
======================= topic 5 : QuestionSet 5 =======================
119. A > D
• Slack은 모든 커뮤니케이션을 한 곳에서 유지하고 거의 모든 곳에서 쉽게 검색할 수 있도록 하여 팀의 생산성을 높이는 인기 있는 팀 협업 서비스로 모든 메시지, 파일, Twitter, Dropbox, Google Docs, Azure DevOps 등 모든 것이 함께 제공됨

120. A > D
• 자율성을 기준으로 팀이 자율적으로 수행할 부분은 stories/tasks

121. A
• Kanban board / Task board 는 작업 흐름을 시각화하고 최적화하기 위한 메트릭 모니터링 지원
• Kanban은 고품질 소프트웨어를 지속적으로 제공할 수 있는 팀의 능력을 최대화하기 위해 작업흐름을 시각화하려면 팀의 워크플로 단계를 매핑하고 이에 맞게 Kanban 보드를 구성

122. A,C,D > C,D,E
분석의 초점이 사람이 아닌 과정으로 What의 질문들이 솔루션

123. C > D
• 프로덕션 코드를 포함하는 하나의 메인 분기를 생성하고(체크인된 코드가 항상 해제될 수 있는 상태) 각 기능에 대해 기능 분기를 생성

124. B
• Jenkins를 사용하여 Azure DevOps Services 및 TFS에 대한 서비스 후크를 만들 수 있음
> 서비스 구독 이벤트는 코드 푸시된 이벤트를 사용해야 하며 코드가 Git repo로 푸시될 때 트리거됨
125. B
126. A
변경사항을 커밋할 때 > "코드 푸시 이벤트를 사용"
127. B

128. D > B
• Git history는 클라이언트 개발 머신에 복제되며 서버에 연결되지 않은 경우에도 볼 수 있고 
Visual Studio 및 웹 포털에서 기록을 볼 수 있음
** Azure Repos는 Git 및 TFVC(Teams Foundation Version Control)의 두가지 버전 유형을 지원
A : TFVC 파일 기록은 클라이언트 개발 컴퓨터에서 복제되지 않아 서버에 연결된 경우에만 지원

129. D
• Visual Studio Codespaces는 GitHub 및 통합 디버깅을 포함하여 가장 다양한 프로젝트 또는 작업을 수용하도록 구축되어 원격 개발 확장을 지원하고 백엔드 환경 외에도 프론트엔드 편집기를 지원

130. D
• Slack을 사용하여 Azure DevOps에 대한 서비스 후크를 만들어 완료된 빌드, 코드 변경, 끌어오기 요청, 릴리스, 작업 항목 변경 등과 같은 Azure DevOps 조직의 이벤트에 대한 응답으로 Slack에 메시지를 게시함

131. C,D > B,D
• Azure Monitor 작업 그룹 구성에서 웹훅의 URL은 논리앱의 URL이어야 논리 앱에서 팀 커넥터를 사용하여 팀 채널에 메시지를 보낼 수 있음 > HTTP 요청 트리거 사용

132. 1-1 > 3-1
• 알림을 수신하기 위해 리포지토리 또는 프로젝트의 모든 리포지토리를 구독함

133 C
• Wiki에 Git 리포지토리를 사용하기 위해서 사전 요구 사항으로
☞ 팀 프로젝트가 있어야 하므로 팀 프로젝트를 생성
☞ 프로젝트에 대해 Azure Repos 서비스를 사용하도록 설정해야함
☞ 팀 프로젝트에 Git 리포지토리가 정의되어 있어야 하고 이상적으로 이 리포지토리에는 wiki에 게시 하려는 Markdown 파일이 하나 이상 포함되어 있어야함
☞ 코드를 wiki로 게시하려면 권한이 있어야 하는데 기본적으로 Cotributors 그룹의 멤버에 대해 설정됨
☞ Git 리포지토리에 기여할 수 있는 권한이 있는 사용자는 wiki 페이지를 추가하거나 편집할 수 있음

134. D
Slack , MS Teams

135. B
• 상태 코드 200은 서버가 요청을 제대로 처리했다는 뜻
• 백엔드 정보가 포함된 질문은 가용성 테스트로 사이트에 ping을 보내는 것보다 복잡한 시나리오.. SQL 데이터베이스나 스토리지에 문제가 있을 수 있으며 간단한 가용성 테스트로는 이러한 오류를 잡을 수 없지만 애플리케이션 맵을 사용하면 잡을 수 있음. 가용성 테스트로 테스트하면 사이트가 작동하지만 반드시 작동하지 않는 것을 확인할 수 있음
D : 애플리케이션 맵은 분산 애플리케이션의 모든 구성 요소에서 성능 병목 현상 또는 장애 핫스팟을 찾는데 도움이 되어 맵의 각 노드는 응용 프로그램 구성 요소 또는 해당 종속성을 나타냄.
A : 서비스 맵은 windows 및 Linux 시스템에서 응용 프로그램 구성 요소를 자동으로 검색하고 서비스간의 통신을 매핑하여 중요한 서비스를 제공하는 상호 연결된 시스템인 서버를 생각하는 대로 볼 수 있음, 서비스 맵은 에이전트 설치 외에 구성이 필요하지 않은 모든 TCP 연결 아키텍처에서 서버, 프로세스 및 포트간의 연결을 잘 보여줌.

======================= topic 6 : QuestionSet 6 =======================
136. B
• PAT(Private Access Token), 개인 액세스 토큰을 사용하면 사용자 이름과 암호를 직접 사용하지 않고도 Azure DevOps와 TFS(Teams Foundation Server)에 액세스 할 수 있음

137. 3-1-4 > 3-4-1
Project1 : 프로젝트 팀은 향후 파이프라인 구성 변경을 관리하는 데 사용하고자 하는 사전 구성된 YAML 파일을 제공합니다.
Project2 : 프로젝트의 민감도를 높이려면 소스 코드가 회사 네트워크의 관리되는 윈도우즈 서버에서 호스팅되어야 합니다.
Project3 : 프로젝트 팀은 개발자가 최신 버전으로 작업할 수 있도록 중앙 집중식 버전 제어 시스템을 요구합니다.
1) Azure Repo의 GIt은 파이프라인에서 참조할 수 있도록 YAML 파이프라인 구성 파일을 저장할 수 있음
2) GitHub Enterprise는 사내에서 비공개로 Git Repo를 호스팅할 수 있는 유일한 솔루션
3) Assembla SVN은 중앙 집중식 버전 제어

138. B ***
• Octopus Tentacle은 Octopus Server와 통신하기 위한 경량 에이전트 서비스
DevOps에 이미 빌드 및 릴리스 파이프라인이 있는데 Octopus를 사용??
139. A ***
• 해당 문제에서 애플리케이션은 온프레미스 종속성 관리 시스템에 종속되기 때문에 한 가지 옵션은 빌드를 수행할 온프레미스 서버를 만드는 것
☞ 여기에서 자체 호스팅 에이전트를 사용하고 Azure DevOps 머신을 등록한 다음 Java 설치 프로그램 Task를 사용하여 애플리케이션 빌드에 사용할 Java 버전을 지정할 수 있음
140. B
141. B

142. A
• 스쿼시 병합은 Pull 요청을 완료할 때 토픽 분기의 Git 히스토리를 압축할 수 있는 병합 옵션으로 토픽 브런치의 각 커밋이 기본 브런치의 히스토리에 추가되는 대신 스쿼시 병합은 모든 파일 변경 사항을 가져와 기본 브런치의 단일 새 커밋에 추가함
• 스쿼시 병합은 파일 변경 사항만 제공하고 일반 병합은 파일 변경 사항 및 커밋 기록을 제공하는 차이점
143. B,C,D
• Jenkins는 TFS에 연결하고 프로젝트 업데이트를 확인하려면 플러그인이 필요로함
☞ 내장 Git 플러그인 또는 Team Foudation Server 플러그인은 몇 분마다 Team Services 리포지토리를 폴링하고 변경 사항이 감지되면 작업을 대기열에 추가할 수 있음
• Azure DevOps/Visual Studio Team Services를 사용하여 개인 액세스 토큰을 만듦
• Visual Studio Team Services를 사용하여 자격 증명을 생성한 후 Jenkins에서 해당 자격 증명을 사용해야 함

144. 4-1-3-2 > 4-1-1-1
1) "프로젝트 리드는 저장소의 개별 파일 및 폴더에 대한 액세스를 제한할 수 있어야 합니다."
☞ TFVC를 사용하면 세분화된 권한을 적용하고 액세스를 파일 수준으로 제한할 수 있음
2) "버전 제어 시스템은 기본 분기에 대한 변경 사항을 병합하기 전에 서버에서 다음 규칙을 적용해야 합니다. (두 명 이상의 프로젝트 구성원이 변경 사항을 검토, 변경 사항은 하나 이상의 작업 항목에 연결)"
☞ Git은 새 프로젝트의 기본 버전 제어 공급자로 TFVC에서 중앙 집중식 버전 제어 기능이 특별히 필요한 경우가 아니면 프로젝트의 버전 제어에 Git을 사용해야함
3) "프로젝트 구성원은 Xcode에서 직접 Azure Repository에서 작업할 수 있어야 합니다.'
Xcode는 Git 및 Subversion의 두가지 소스 제어 시스템을 지원, Subversion은 항상 서버 기반으로 서버는 일반적으로 원격 컴퓨터(서버를 로컬로 설치할 수 있음)에 있고 Git은 로컬 저장소로만 사용하거나 원격 컴퓨터에 Git 서버를 설치하여 팀 구성원 간에 저장소를 공유할 수 있어 혼자 작업하는 경우 서버를 설정할 필요가 없기 때문에 Git을 사용하는 것이 가장 쉬움
☞ azure repos는 Git, TFVC만 지원
4) "해제 분기는 프로젝트 리드에 의해서만 보거나 편집할 수 있어야 합니다.'
☞ 읽기전용으로 TFVC를 사용할 수 있지만 편집 권한이 있으므로 GIt

145. C
• 빌드 파이프라인에서 코드 적용 범위 결과 게시 작업을 사용하여 Cobertura 또는 JaCoCo 형식의 빌드에서 생성된 Azure Pipelines 또는 TFS에 코드 적용 범위 결과를 게시함.

146. 4-5 > 3-1 ***
1) 'Fianalize build' 단계는 구성 단계가 아님 > 3개의 stage
2) 'Build_vm'이라는 하나의 job ??

147. 3-1 > 4-4 ??
질문은 agent 풀 유형을 묻는 것으로 호스팅 및 자체 호스팅의 두가지 유형만 존재함??

148. A (145번과 같은 문제)
• 빌드 파이프라인에서 코드 적용 범위 결과 게시 작업을 사용하여 Cobertura 또는 JaCoCo 형식의 빌드에서 생성된 Azure Pipelines 또는 TFS에 코드 적용 범위 결과를 게시함

149. B > A
• 자체 호스팅 에이전트에서 파이프라인을 실행하면 기본적으로 두개의 연속 실행 사이에 하위 디렉터리가 정리되지 않음, 결과적으로 작업이 이를 사용하도록 구현되는 경우 증분 빌드 및 배포를 실행할 수 있어 작업의 작업 공간 설정을 사용하여 이 동작을 재정의할 수 있음


150. 1-2 > 2-1
App1 - 각 반복에서 이전 버전의 App1 기존 인스턴스 집합을 새 버전의 앱 인스턴스로 교체
App2 - 앱의 기능을 검증하기 위해 새로운 버전의 제한된 배포를 롤아웃 하고 테스트에 성공하면 롤아웃을 확장
1) 롤링 배포는 각 반복에서 고정된 가상 머신 세트(롤링 세트)에 있는 애플리케이션의 이전 버전 인스턴스를 새 버전의 인스턴스로 바꿈
2) Canary 배포 전략은 새 버전의 애플리케이션을 롤아웃하는 것과 관련된 위험을 완화하는 데 도움이 되는 고급 배포 전략으로 먼저 서버의 작은 하위 집합에 변경 사항을 롤아웃할 수 있고 새 버전에 대한 확신이 높아지면 인프라의 더 많은 서버에 릴리스하고 더 많은 트래픽을 이버전으로 라우팅할 수 있음

151. C > D
• 기여자 권한은 프로젝트 코드 기반 및 작업 항목 추적에 완전히 기여할 수 있는 권한이 있음

152. C > A
• CSE(사용자 지정)는 스크립트만 실행하고 일관성을 확인하지 않고 DSC는 정기적으로 대상을 확인하여 일관성을 유지함
가상 머신이 일관된 구성을 유지 .. > 유지 관리의 문제는 DSC를 위한 작업

153. C > B
• 업스트림 소스를 사용하면 단일 피드를 사용하여 "원격 피드"에서 생산하는 패키지와 소비하는 패키지를 모두 저장할 수 있는데 여기에는 'npmjs.com','nuget.org'와 같은 공개 피드와 조직의 다른 Azure DevOps 피드와 같은 인증된 피드가 모두 포함됨
• 업스트림 소스를 활성화하면 피드에 연결된 모든 사용자가 원격 피드에서 패키지를 설치할 수 있으며 피드에 복사본이 저장됨

154. 1-2-5
DSC 메타 구성 만들기 > 메타 구성을 가상머신에 복사 > 가상머신에서 'setdsclocalconfigurationmanager.py'실행
• 'setdsclocalconfigurationmanager.py' 명령어는 메타 구성 MOF 파일을 컴퓨터에 적용하는 형식

155. simulation

156. 4-1-3 
1) 첫번째 줄의 그룹은 컨테이너를 구축하는 데 사용할 기본 이미지를 선언, 로컬 시스템에 이미 이 이미지가 없으면 도커가 자동으로 이미지를 시도하고 가져오는데 sdk:2.1은 설치된 .NET core 2.1 SDK와 함께 제공되므로 버전 2.1을 대상으로 하는 ASP .NET Core 프로젝트를 빌드하는 작업에 달려 있음
> 전체 SDK 패키지를 사용하여 빌드
2) 복원, 빌드, 게시
3) 새단계 런타임에 필요한 모든 것을 포함하는 슬림 이미지로 dotnet publish 암시적 복원 및 빌드를 수행


157. 2-3 > 1-3
• 체크인 상태는 git이 아닌 tfvc에 대한 것

158. A
• 분기 정책은 팀이 중요한 개발 분기를 보호하는 데 도움이 되고 정책은 팀의 코드 품질 및 변경 관리 표준을 시행함

159. B
160. A
• 스쿼시 병합은 단일 커밋을 수행함
161. B
162. B

163. D > A
https://docs.docker.com/develop/develop-images/multistage-build/
• 다단계 빌드를 사용하면 빌드 분은 이미지 크기를 신경 쓰지 않고 실행 파일의 크기만 신경쓰고 Dockerfile를 쓸 수 있음
• 다단계 빌드는 데몬 및 클라이언트에서 Docker 17.05 이상이 필요한 새로운 기능으로 다단계 빌드는 Dockerfile을 쉽게 읽고 유지 관리하면서 최적화하는 데 어려움을 겪고 있는 시나리오에 유용함
C : 스웜은 스웜 모드에서 실행되고 관리자 및 작업자 역할을 하는 여러 Docker 호스트로 구성됨

164. D > C
• 다단계 빌드를 사용하면 중간 레이어 및 파일 수를 줄이는데 어려움을 겪지 않고도 최종 이미지의 크기를 크게 줄일 수 있음
• 각 From 명령어는 다른 기반을 사용할 수 있으며 각 명령어는 빌드의 새 단계를 시작하는데 최종 이미지에서 원하지 않는 모든 것을 남겨두고 한 단계에서 다른 단계로 아티팩트를 선택적으로 복사할 수 있음
• 최종이미지는 SDK가 아닌 런타임 이미지여야함

165. B (175~178번 문제와 같은 시나리오)
• '일괄변경' 옵션을 선택하면 빌드가 실행 중일 때 시스템이 빌드가 완료될 때까지 기다린 다음 아직 빌드되지 않은 모든 변경 사항의 다른 빌드를 큐에 넣음
• 대신 Visual Designer에서 CI(지속적 통합)을 활성화

166. 3-3 > 2-3
1) 사용자 지정 ACR을 설정하고 기존 k8s 클러스터에 연결하여 공용 도커 허브 대신 개인 컨테이너 레지스트리에서 이미지를 가져오도록 할 수 있음
2) AKS 클러스터가 ACR과 상호 작용할 수 있도록 Azure AD 서비스 주체가 사용됨

167. B
• package.json 파일 내에서 devDependecies와 프로덕션 종속성 간에 npm 종속성을 분리해야 하는데 핵심 부분은 npm 패키지를 설정할 때 --production 플래그를 사용해야 한다는 것으로 --production 플래그는 devDependecies 섹션에 정의된 모든 패키지를 제외함

168. A
이미지 레지스트리는 나머지 3개 중 가장 빠른 옵션
• Docker 작업을 사용하여 ACR에 로그인한 다음 후속 스크립트를 사용하여 이미지를 가져오고 컨테이너 이미지에 취약점을 스캔 가능 
• 빌드 또는 릴리스 파이프라인에서 도커 작업을 사용하는데 이 작업은 Docker 또는 ACR와 함께 사용할 수 있음
C : 가능한 한 빨리 익스플로잇을 탐지하기를 원하므로 배포할 때까지 기다리면 안됨
D : 이미지가 제품 컨테이너에 들어갈 때까지 기다려야함

169. C > D
• Azure Stack은 주문형 확장 가능한 컴퓨팅 리소스의 한 유형으로 VM을 제공함
☞ 컴퓨팅 환경에 대한 더 많은 제어가 필요한 경우 VM을 선택할 수 있음
B : Azure DevTest Labs는 테스트 목적으로만 사용됨

170. C,D > D,E
• 성공적인 에이전트 설치를 위해서는 PAT가 필요하고 PAT를 생성한 후 에이전트 설치를 위해 빌드 서버에서 config.cmd를 실행

171. A,C,D
• az login --service-principal --username ff6f62b4-d57b-42de-b0d0-1a0d6e34ac94 --password LlaeZNoEJ65st1_lIT.-YKTJzo8oyW8456 --tenant 6184a51f-7158-48ba-adee-
51e5f34edd5c 
{ "appId": "ff6f62b4-d57b-42de-b0d0-1a0d6e34ac94", 
"displayName": "ServicePrincipalName", 
"name": "http://ServicePrincipalName", 
"password": "LlaeZNoEJ65st1_lIT.-YKTJzo8oyW8456", 
"tenant": "6184a51f-7158-48ba-adee-51e5f34edd5c"
}

172. 1-3-6 > 6-3-1
Blobs?? Files??

173. A > C
• 빌드 및 테스트는 다단계 Docker 파일을 사용하여 컨테이너 내에서 실행되기 떄문에 이러한 테스트 결과는 파이프라인에 다시 게시되지 않음


174. A > D
• 기술적인 부채는 '빨리','지금만','나중에 코딩할 것'의 방식으로 재작업이 종종 필요함

175. C > B
• Checks API에 대한 쓰기 권한은 GitHub 앱에서만 사용할 수 있음
☞ 참고로 GitHub 앱으로 인증하면 'GitHub 앱에 대한 상위 수준 관리 정보를 검색','앱 설치를 위한 액세스 토큰을 요청'하는 이점이 있음

176. A > B
177. B
178. B

179. 5-7-1-3-4
• 릴리스 파이프라인의 응용 프로그램 부분이 구성되면 보안 스캔 부분을 정의할 수 있음
Baseline Scan 호출 > 파일 다운로드 > 보고서 형식 변환 > 결과 발표 > OWASP 컨테이너 파괴
 

180. 1-3
1) 마스터 브런치는 프로덕션 코드를 포함하며 모든 개발 코드는 언젠가 마스터에 병합됨
2) 개발 브런치에는 사전 프로덕션 코드가 포함되어 있으며 기능이 완료되면 개발에 병합됨

181. B,C > C,E
• 에이전트서버를 늘리고 병렬로 실행되는 작업을 늘려야함

182. A > B
• Flaky(비정상적인) 테스트는 소스 코드나 실행 환경에 변화가 없는 경우에도 합격, 불합격 등 다양한 결과를 제공하는 테스트로 제공되는 코드의 품질에도 영향을 미침

183. 1-5-4-3 > 5-4-3-6
• 배포그룹 만들기 > 에이전트 풀/사양 생성 > 파이프라인 작업 추가/구성 > 파이프라인 실행
1) 배포 그룹을 만들고 각 머신에 태그 할당(여러 그룹을 생성할 수도 있음)
2) 머신을 추가하면 powershell 스크립트를 실행하여 에이전트를 설치함
3) 배포 그룹의 시스템과 파이프라인의 작업 연결 4) 파이프라인 실행

184. A (176~178번 문제와 같은 시나리오)
• Visual Designer에서 다음을 통해 CI(지속적 통합)를 활성화
☞ 트리거 탭을 선택 ☞ 지속적 통합을 활성화
• 빌드 파이프라인의 지속적인 통합 트리거는 코드 변경이 커밋될 때마다 자동으로 새 빌드를 대기열에 넣어햐함을 나타냄

185. A,C *** 정답이 애매함
• 2021년 9월 이후부터 지원되는 버전은 Windows2022, Windows2019, ubuntu-20.04, ubuntu-18.04, macOS-11, macOS-10.14, macOS-10.15

186. 1-2-3
1) JIRA - 보드(대부분 노력 추적에 대해 보드가 적절한 답변임)
2) Jenkins - 빌드 파이프라인(CI/CD 모두를 수행할 수 있지만 여기서는 빌드 파이프라인으로 사용할 수 있음)
3) Octopus - 릴리스 파이프라인(특성을 고려하면 그냥 배포 도구)

187. B
• 배포 대기열 설정을 '최신 배포 및 나머지는 취소' 옵션으로 사용하면 빌드보다 빠르게 릴리스를 생성하고 최신 빌드만 배포하려고함
C : 릴리스 게이트를 사용하면 외부 서비스에서 상태 신호를 자동으로 수집한 다음 모든 신호가 동시에 성공하면 릴리스를 승격하거나 시간 초과 시 배포를 중지하고 일반적으로 게이트는 사고관리, 문제 관리, 변경 관리, 모니터링 및 외부 승인 시스템과 관련하여 사용됨

188. D
• 빌드 설명 정적 코드 분석은 가능한 한 수명 주기 초기에 구현해야 하므로 빌드 프로세스에 포함해야함

189. 4-1-2
• 업스트림 소스를 사용하는 Azure 아티팩트 피드 생성 > Azure 아티팩트 피드를 참조하도록 구성 파일 수정 > 초기 패키지 복원 실행


190. 2-3
• 클라우드 에이전트 전용 job 1개, Task 4개(Nuget 복원, 애플리케이션 컴파일, 파일 복사, 아티팩트 게시)

191. simulation

192. 1-6-5-4-2
https://docs.microsoft.com/ko-kr/azure/automation/tutorial-configure-servers-desired-state
• Azure Automation 상태 구성을 사용하면 서버 구성을 지정하고 시간이 지남에 따라 해당 서버가 지정된 상태에 있는지 확인할 수 있음
☞ Azure Automation DSC에서 관리되는 VM 등록 (onboarding)
☞ Azure Automation에 구성 업로드
☞ 노드 구성으로 구성 파일 컴파일
☞ 관리되는 노드에 노드 구성 할당
☞ 관리되는 노드에 대한 준수 상태 확인

193. C > A
• rebase를 사용하여 master 분기의 최신 변경 내용으로 분기를 업데이트하는 문제를 해결하고 현재 분기의 커밋에서 변경한 내용을 다른 분기의 기록에서 재생하여 현재 분기의 커밋 기록은 rebase의 대상 분기에서 가장 최근 커밋부터 시작되도록 다시 작성함.
☞ 기능 분기의 변경 내용을 기본 분기의 최신 변경 내용에서 다시 적용하면 기본 분기의 최신 버전에서 변경 내용을 테스트하면서 Git 기록을 정리할 수 있음
재정의 - rebase
통합 - merge

194. A ??
195. A
• 파이프라인 캐싱은 한 실행의 출력이나 다운로드 된 종속성을 나중에 실행하는데 다시 사용할 수 있도록하여 빌드 시간을 줄일 수 있음. 따라서 동일한 파일을 만들거나 다시 만드는 비용을 줄이거나 redownload를 진행하는데 캐싱은 각 실행이 시작 될 때 동일한 종속성이 다운로드 되는 시나리오에 특히 유용함
196. B
현재 파이프라인은 단일 작업이므로 병렬 작업을 활성화해도 개선되지 않음

197. B
198. B
연결/중첩 템플릿이 필요함

199. B
200. B
아티팩트를 배포하려면 자체 호스팅 에이전트가 필요로함
