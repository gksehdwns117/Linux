 1. 2-1 > 2-1-2
1) 서비스를 사용하는 4명의 고객, Webjob의 각 인스턴스는 단일 고객에 대한 데이터를 처리하고 싱글톤 인스턴스로 실행되어야 함 > VM의 갯수는 4개를 요함
2) 격리된 Azure 리소스는 기본적으로 격리된 네트워크 환경에 있어야함.
> 격리 계층에서 App Service 환경은 앱을 실행하는 격리된 작업자 수를 정의하며 각 작업자에게 요금을 부과함

2. 4-3-1 > 2-3-1
1) Azure Functions를 k8s에 배포하려면 'func k8s deploy' 명령을 사용해야함
2) 기본적으로 KEDA는 30초마다 모든 'ScaleObject'에서 각 트리거 소스를 확인함
> ScaleObject --polling interval
3) ScaledObject용 k8s 비밀 리소스에 연결 문자열 저장. k8s secretes의 Secret Store 연결 문자열

3. 2-1-2-1-1 > 2-1-3-3-1
1) 리소스 그룹을 먼저 만들고, 리소스 그룹 정보를 기반으로 앱 서비스 계획을 생성 ('--sku FREE')
2) 앱 서비스 계획을 만든 다음, 웹앱 생성
3) 웹앱 생성 시 먼저 만든 앱 서비스 계획을 기반으로 한다는 명령어
4) 계획 생성, 웹앱 생성, 웹앱 배포
5) 웹앱 배포시 Source repo를 지정
> 자동으로 통합하기 위한 지속적인 배포 명령어 사용이 더 알맞음(--git-token)

4. A *** > B
사진을 처리하기 위한 Azure Functions가 필요??

5. B(yes)
• 응용 프로그램에 대한 준비 동작을 추가할 수 있는 두가지 방법
> web.config 파일에 applicationlnitialization 구성 요소를 추가
> 웹 응용 프로그램에 대한 앱 설정을 추가
• 교체(스왑) 작업은 대상 슬롯으로 교체하기 전에 사용자 지정 워밍업이 완료될 때까지 대기함
6. A(No)
단순히 자동 스왑을 활성화하는 것으로 스크립트가 실행되고 리소스가 사용 가능한지 확인 X
7. A(No)
• 스왑작업이 발생하기 전에 스크립트가 실행되고 리소스가 사용 가능한지 확인하는 유일한 방법을 applicationIntialization 구성 요소에서 사용자 정의 초기화 작업을 지정하는 것뿐임
> 자동 스왑을 활성/비활성하는 작업과는 무관함

8. B(4번과 같은 시나리오)
가장 적절한 답으로는 Blob 스토리지 트리거를 사용하여 Azure 함수를 만드는 것
• 기존 표준 성능 저장소 계정을 프리미엄 성능의 BlockBlob 저장소 계정으로 변환할 수 없고, 프리미엄 성능 저장소 계정으로 마이그레이션하려면 프리미엄 BlockBlob 계정을 만들고 데이터를 새 계정으로 마이그레이션해야함

9. 1-4
1) HTTP 요청 헤더 ASP.NET을 사용 중이고 클라이언트 인증서 인증을 사용하도록 앱을 구성하는 경우 인증서는 'HttpRequestClientCertificate' 속성을 통해 사용할 수 있음
2) Base64 다른 애플리케이션 스택의 경우 'X-ARR-ClientCert' 요청 헤더의 Base64 인코딩 값을 통해 클라이어트 인증서를 앱에서 사용할 수 있음

10. 1-5-4
리눅스를 지원하는 위치가 아닌 리소스 그룹이 아닌 새로운 리소스 그룹에 앱서비스 계획과 웹앱 생성

11. 4-3-1-2
변수선언(Bash shell script) > 웹앱생성 > 컨테이너 설정(앱 실행 확인 가능) > URL 도메인 할당

12. 2-4-1 > 2-7-3
1) Vnet 지원은 프리미엄 계층에서만 지원하기 떄문에 Premium Functions 생성
2) 애플리케이션을 삭제하는 경우 인증 제거 > 시스템 할당 관리 ID 생성
(Key vault는 현재 시스템 할당 관리 ID만 지원??)
3) 액세스 정책 생성

13. D
• 표준 서비스 App service plan은 프로덕션 워크로드 실행용으로 기본 제공 네트워크 로드 밸런싱 지원은 인스턴스 간에 자동으로 분산하고 트래픽 요구사항에 맞게 가상 머신 인스턴스의 수를 자동으로 조정할 수 있는 자동 크기 조정이 포함됨.
• App Service의 자동 크기 조정은 Standard에서부터 지원(Basic과 Free sku는 지원 X)

14. 1-3-2-4-5
리소스 그룹을 생성 > plan 생성 > 웹앱 생성 > 슬롯 생성 > 배포 소스 지정

15. 3-2-2 > 3-1-1 ***

16. B > A	 /****
• Durable Functions는 장기 실행 기능을 더 짧은 활동 기능으로 분해할 수 있도록 하여 장기 실행 작업을 지원
> 시나리오의 메시지처리의 시간초과 문제를 해결할 수 있는 솔루션??
17. A
• HTTP 트리거 페이로드를 대기열 트리거 기능에 의해 처리되도록 대기열에 전달할 수 있고 해당 방식을 사용하면 실제 작업을 연기하고 즉각적인 응답으로 반환할 수 있음
18. B
Always On 설정은 HTTPTrigger에서 깨우기를 활성화하지만 최대 초과 시간인 230초를 초과하는 것을 방지하지는 않음

19. A (4,8번과 같은 시나리오)

20. A > B
• 변경 피드는 스토리지 계정의 Blob 및 Blob 메타데이터에 발생하는 모든 변경 사항에 대한 트랜잭션 로그를 제공함. 변경 피드는 이러한 변경에 대한 순서가 지정되고 보장된 내구성 있고 변경할 수 없는 읽기 전용 로그를 제공함. (이러한 로그를 비동기식/증분식/전체식 으로 처리 가능)

21. 2-4-1-5-3 >  ***
From - WorkDir - Copy - Run - CMD
1) From 명령어는 Dockerfile을 작성할 때 반드시 한 번 이상 입력해야 하며, 이미지의 이름의 포맷은 docker run 명령어에서 이미지임을 사용했을 때와 같음(이미지가 도커에 없다면 자동 pull)
2) WorkDir 명령어는 명령어를 실행할 디렉터리를 지정함 , 뒤에 실행할 RUN, CMD, ENTRYPOINT, COPY/ADD 명령어에 대한 작업 디렉터리를 설정함
3) CMD 명령어는 컨테이너가 시작될 때마다 실행할 명령어를 설정하며, dockerfile에서 한번만 사용이 가능함
4) Copy 명령어는 파일을 이미지에 추가하는 명령어로 파일은 dockerfile에 위치한 디렉터리인 컨텍스트에서 가져옴
5) Run 명령어는 이미지를 만들기 위해 컨테이너 내부에서 명령어를 실행함

22. D
• 함수 앱이 유휴 상태가 된 경우 소비 계획으로 인해 새 Blob의 처리가 10분 지연 될 수 있음
> 해당 대기 시간을 방지하기 위해 Always On이 활성화된 App Service 계획으로 전환함

23. 2-1-4
1) 각 리소스의 이름에는 루프의 현재 반복을 반환하는 copyIndex() 함수가 포함(0부터 시작)
2) 복사 템플릿의 리소스 섹션에 복사 루프를 추가하여 배포할 리소스 수를 동적으로 설정
또한, 템플릿 구문을 반복하지 않아도 되는 것을 의미
3) Depends On을 사용함으로써 하나의 리소스를 하나 이상의 리소스에 종속된 것으로 정의

24. y-n-n-y > n-y-y-y
1) 코드는 대기열에서 주문이 처리된 시간을 기록합니다.
• Insertion Time(메시지가 큐에 추가된 시간) , Expiration Time(메시지가 만료되는 시간)
2) ProcessOrders(주문 처리) 기능이 실패하면 첫 번째 시도를 포함하여 주어진 주문에 대해 최대 5번까지 재시도합니다.
• maxDequeueCount : 포이즌 큐로 메시지를 이동하기 전에 메시지 처리를 시도하는 횟수로, 기본값은 5
3) 대기열에 주문이 여러 개 있을 경우 대기열에서 주문 일괄 처리가 검색되고 ProcessOrders 함수는 주문을 처리하기 위해 여러 인스턴스를 동시에 실행합니다.
• 대기 중인 여러 대기열 메시지가 있는 경우 대기열 트리거는 메시지 일괄 처리를 검색하고 동시에 함수 인스턴스를 호출하여 처리하는데 기본적으로 배치 크기는 16이고 처리 중인 숫자가 8로 줄어들면 런타임은 다른 배치를 가져와서 해당 메시지 처리를 시작함. 따라서, 하나의 VM에서 기능당 처리되는 동시 메시지의 최대 수는 24개
4) ProcessOrders 기능은 주문을 Azure Table Storage에 있는 Orders 테이블로 출력합니다.
• [Table("Orders")]|Collector<Order> 테이블 바인딩 그리고 코드에서 tablebindings 순서를 추가

25. Eventual - Strong - Eventual > Strong - Bounded Staleness - Eventual
1) Strong 일관성은 선형성을 보장, 읽기는 항목의 가장 최근에 커밋된 버전을 반환하도록 보장하고 클라이언트는 커밋되지 않은 쓰기나 부분적인 쓰기를 절대 볼 수 없음(사용자는 항상 최신 커밋된 쓰기를 읽을 수 있음)
2) 제한된 부실의 읽기는 접두사 보장을 준수하도록 보장되고, 항목의 최대 "K" 버전 또는 "t" 시간 간격만큼 쓰기보다 지연될 수 있어 제한된 부실을 선택하면 "부실"을 두 가지 방법으로 구성
3) 읽기에 대한 주문 보장이 없어 더 이상 쓰기가 없으면 복제본이 결국 수렴됨.

26. 1-1
1) Azure Powershell VM에서 직접 이미지를 만들면 OS 디스크 및 데이터 디스크를 포함하여 VM과 연결된 모든 디스크가 이미지에 포함되어 Sysprep을 사용하여 가상 머신을 일반화한 다음 Powershell을 사용하여 이미지를 생성
2) VM이미지는 Storage 페이지 Blob으로 저장된 VHD 집합에 대한 포인터 및 메타데이터 모음

27. B,D??? *** 

28. 3-4-5-2-1 
https://imgur.com/gpv3jLW
내보내기 > 계정 생성 > 수정 > 배포 > Azcopy 사용

29. 1-4
1) 명령 실행 기능은 VM 내에서 스크립트를 실행하려는 모든 시나리오에서 유용하며 부적절한 네트워크 또는 관리 사용자 구성으로 인해 RDP 또는 SSH 포트가 열려 있지 않은 VM의 문제를 해결하고 수정하는 유일한 방법 중의 하나
2) 사용자 정의 스크립트 확장은 배포 후 구성, 소프트웨어 설치 또는 기타 구성, 관리 작업에 유용함

30. 4-3-2-1

31. 1-3 > 2-1
1) IdentityId가 아닌 'IdentityType' 메타데이터를 사용
2) 시스템 할당 관리 ID를 사용하면 서비스 인스턴스에서 직접 관리 ID를 활성화 할 수 있어 해당 서비스 인스턴스의 수명 주기에 연결된 Azure AD ID가 생성됨

32. A > B
• 함수 앱이 기본 소비 계획에서 실행되는 경우 Blob이 추가 또는 업데이트되고 트리거되는 기능 사이에 최대 몇 분의 지연 있을 수 있어 짧은 대기 시간이 필요한 경우 App Service 계획에서 함수 앱을 실행하는 것이 좋음

33. A ***

34. n-n-n > n-y-n
1) 'AzScheduledQueryRuleSource'는 CPU가 아니라 Heartbeat
2) 'AzScheduledQueryRuleSource'는 CPU가 아니라 Heartbeat
3) 일정은 2시간이 아닌 60분 단위 > 'FrequencyInMinutes'는 경고 빈도

35. 5-6 > 1-3
1) 사용자 정의 처리기는 Go 또는 Rust와 같은 HTTP 서버 프로세스를 실행하여 모든 언어 또는 런타임에서 함수를 생성하는 데 사용할 수 있음
2) 트리거 함수는 트리거에 의해 호출되며 정확히 하나만 가질 수 있고 특정 트리거는 데이터를 코드에 연결하는 선언적 방법을 제공하는 바인딩을 제공할 수 있음

36. 1-4
1) 'WEBSITES_ENABLE_APP_SERVICE_STORAGE' 설정이 지정되지 않거나 false로 설정된 경우 /home/ 디렉터리는 확장 인스턴스간에 공유되지 않으며 작성된 파일은 다시 시작해도 지속되지 않아 명시적으로 true로 설정하여 마운트를 활성화 시켜야함
2) /home/ 디렉터리 공유
• 영구 공유 스토리지 사용
앱의 파일 시스템에서 '/home' 디렉터리를 사용하여 다시 시작할 때마다 파일을 유지하고 인스턴스간에 공유할 수 있고 컨테이너 앱에서 영구 스토리지에 액세스할 수 있도록 앱의 /home이 제공됨. > 영구 스토리지가 사용하지 않도록 설정되면 앱을 다시 시작할 때마다 또는 여러 인스턴스간에 /home 디렉터리에 대한 쓰기가 유지되지 않음
> 기본적으로 영구 스토리지는 사용하지 않도록 설정되고, 설정은 앱 설정에서 공개되지 않은데 이 설정은 'Websites_Enable_App_Service_Storge 앱 설정을 지정함

37. A,C > A,D ??? ***
• 종단 간 SSL의 경우 Azure App Service 웹앱과 같은 신뢰할 수 있는 Azure 서비스는 애플리케이션 게이트웨이에서 백엔드를 화이트리스트에 추가할 필요 없음 > 인증서 추가할 필요가 없음(C x)

38. A > B (32번과 같은 시나리오)
• 변경피드는 시간별 세그먼트로 구성되지만 몇분마다 추가되고 업데이트되는 변경 로그로 이러한 세그먼트는 해당 시간에 발생하는 Blob 변경 이벤트가 있는 경우에만 생성됨

39. y-y-n-y > y-n-n-y
• 'CloudstorageAccount storage Account = CloudStorage Account.parse(storageConnectionString) 
: 연결 문자열에서 스토리지 계정 검색
• CloudTableClient tableClient = storageAccount.createCloudTable();
: 테이블 클라이언트를 생성
1) 'CloudTableClient' 개체를 사용하면 테이블 및 엔터티에 대한 참조 개체를 가져올 수 있음
2) TableOperation.insert를 사용하여 새레코드가 삽입되어 오래된 레코드는 업데이트되지 않음
> 이전 레코드를 업데이트하려면 TableOperation.insertOrReplace를 사용해야함
3) 파티션 키는 자동을 생성되지 않음
> 테이블에 저장되는 첫번째 매개변수는 gameID 이지만 그렇다고 해서 반드시 파티션 키로 자동으로 사용되어 지는 것은 아님 > 엔터티 생성자 내에서 모든 매개변수에 파티션 및 행 키를 할당할 수 있음 > 파티션이 자동으로 생성되는 것은 아님
4) 점수 데이터 저장용 코드 07~08행 참조

40. n-n-y > y-n-y
1) 'AcquireLeaseAsync'가 임대 시간을 지정하지 않음(null값)
> 임대 시간은 획득할 시간 범위를 나타내는 TimeSpan으로 초 단위로 반내림되는데 null인 경우 무한 임대가 획득됨. null이 아닌 경우 15초~60초 사이여야함
2) 'GetBlockBlobReference' 메서드는 이 컨테이너의 블록 Blob에 대한 참조를 가져옴
3) 'BreakLeaseAsync' 메서드는 이 컨테이너의 현재 임대를 중단하는 비동기 작업을 시작함

41. C > B
• 표준 우선순위 - 재수화 요청은 접수된 순서대로 처리되며 최대 15시간이 소요
• 높은 우선순위 - 복원 요청은 표준 요청보다 우선 순위가 지정되며 크기가 10GB 미만인 개체의 경우 1시간 이내에 완료될 수 있음

42. 1-2-3 > 4-2-3
1) Bounded Staleness 읽기는 일관된 접두사 보장을 준수 하도록 보장되고 항목의 최대 "K"버전 또는 "T" 시간 간격만큼 쓰기보다 지연될 수 있음
> 강함 일관성은 선형성(요청을 동시에 처리하는 성질)을 보장하여 읽기는 항목의 가장 최근에 커밋된 버전을 반환하도록 보장하지만 클라이언트는 커밋되지 않은 쓰기나 부분적인 쓰기를 절대 볼 수 없어 항상 최신 커밋된 쓰기만 읽을 수 있음
2) 단일 쓰기 지역으로 구성된 다중 지역 Cosmos 계쩡의 경우 Azure CLI 또는 Azure Portal을 사용하여 자동 장애조치를 활성화함
3) 다중 지역의 옵션이 필요

43. 1-4-3 > 4-3-3
1) 다중 컨테이너 그룹이 현재 Linux 컨테이너로 제한되므로 -is--linux 명령어 사용

44. 2-1-4-

45. 5-1-2 > 2-1-5
• 메타데이터 업데이트에 관한 솔루션으로 먼저 가져와서 Blob의 속성과 메타데이터를 채워야함
(업데이트 하려는 경우는 가져오지 않고 새 메타데이터를 설정하기만 하면됨)
> 메타데이터를 업데이트하고 가장 적합한 것은 Metadata.Add
> 비동기 작업을 시작하는 메서드를 사용하여 Blob의 메타데이터를 업데이트(SetMetadataSync)

46. B
• 솔루션은 캡처 및 파티셔닝을 언급, 이는 이벤트 허브의 기능이며 이벤트 그리드에서 사용할 수 있는 참고 사항이므로 이벤트 그리드에 대한 "파티션 키 및 캡처 활성화"에 대하여 말하는 것은 의미가 없음
• 이벤트 허브의 캡처 기능을 사용하여 수행되는 Azure Blob Storage에 데이터를 저장해야함
• 이벤트 그리드는 이벤트 소스에서 이벤트를 제공함

47. A
• Azure.Storage.Queues.QueueClient : .Net v12 와 Azure.Storage.Queues.CloudQueueClient : .Net v11는 레거시 버전의 차이
• "메시지가 처리된 후 지속되어서는 안된다"의 기능은 'AT-Most-Once' 기능으로  
CloudQueueClient에서는 지원하지 않음

48. 1-3-4 > 1-4-3
1) GPv1에서 GPv2로 계정을 업그레이드 하면서 기본값은 핫 티어가 됨.
2) 데이터를 이동하여 가격 책정을 활용하므로 아카이브 데이터를 다른 GPv2로 복사함
3) 현재 핫 티어의 계정을 쿨 상태로 변경함

49. C
• Azure Cosmos DB는 최신 앱 개발을 위한 완전 관리형 NoSQL 데이터베이스로, 한 자릿수 밀리초 응답 시간과 자동 및 즉각적인 확장성은 모든 규모에서 속도를 보장함

50. A
• AzCopy v10 명령줄 유틸리티를 사용하여 스토리지 계정 간에 Blob, 디렉터리 및 컨테이너를 복사할 수 있고, 복사 작업은 동기식이므로 명령이 반환되면 모든 파일이 복사되었음을 나타냄.
• AzCopy 도구는 자동화 스크립트 내에서 도구를 사용하여 데이터가 자동으로 복사 가능함.

51. 4-3 > 4-4
1) 머신의 로컬 서비스에서 메타데이터를 가져오려면 올바른 URL은 
"http://169.254.169.254/metadata/identity/oauth2.0/token"
2) JsonConvert.DeserializeObject 메서드를 사용하여 역직렬화할 수 있어 액세스 코드를 반환

52. 5-4 > 5-3 ***
https://docs.microsoft.com/ko-kr/azure/cosmos-db/index-policy
1) 복합인덱스 > 여러속성을 기준으로 정렬하는 쿼리에는 복합 인덱스가 필요로함, 기본적으로 복합 인덱스는 정의되어 있지 않으므로 필요에 따라 추가해야함
2) 오름차순 > 순서를 지정하는 것은 선택 사항으로 기본값은 오름차순..??? 


53. 2-2 > 3-1
1) 소비자가 파티션을 배포하려면 고속도로에서 데이터를 여러번 보내야 하며 매번 다른키(클라이언트마다 하씩)를 사용해야 함.  6개의 고속도로 > 6개의 파티션
2) 파티션 키 - 고속도로

54. 4-6-7 > 1-4-5
1) Helm 기능은 애플리케이션 관리를 지원, Helm 차트는 가장 복잡한 k8s 애플리케이션을 정의,설치 및 업그레이드 하는 데 도움이 되어 수신 컨트롤러를 생성하려면 Helm을 사용하여 nginx-ingress를 설치함
2) Kubectl을 사용하면 k8s 클러스터에 대해 명령을 실행할 수 있어 포드의 클러스터 IP 주소를 찾으려면 '-o wide' 옵션과 함께 로컬 머신에서 'kubectl get pod' 명령을 사용함
3) 수신 컨트롤러는 k8s 서비스에 대한 리버스 프록시, 구성 가능한 트래픽 라우팅 및 TLS 종료를 제공하는 소프트웨어

55. 1-2-1-1-3
• Service bus 의 filter
> SQL 필터는 도착하는 메시지의 사용자 정의 속성 및 시스템 속성에 대해 브로커에게 평가되는 SQL과 유사한 조건식을 보유하여 모든 시스템 속성은 'sys.' 조건식에서 접두사로 시작해야함
> Boolean 필터는 모든 메시지(true) 또는 수신되는 메시지 중 아무것도(false) 구독에 대해 선택되지 않음
> Correlation 필터는 하나 이상의 도착 메시지의 사용자 및 시스템 속성과 일치하는 조건 집합을 보유

56. 2-4-3-1 > 2-1-4-3
A. POP에 이미지가 캐시에 없는 경우 POP는 오리진 서버에서 파일을 요청합니다.
B. 사용자가 CDN URL에서 이미지를 요청합니다. DNS는 요청을 가장 성능이 좋은 POP 위치로 라우트합니다.
C. 파일에 대한 후속 요청은 CDN 로고 이미지 URL을 사용하여 동일한 POP로 이동할 수 있습니다. TTL이 만료되지 않은 경우 POP 에지 서버는 캐시에서 파일을 반환합니다.
D. 오리진 서버는 로고 이미지를 POP의 에지 서버로 반환합니다. POP의 에지 서버는 로고 이미지를 캐시하고 이미지를 클라이언트로 반환합니다.
• 사용자가 이미지를 요청하면 > 캐시에 없는 경우 오리진 서버에 파일 요청 > 오리진 서버는 로고 이미지를 캐시에 저장 > TTL이 만료될 때까지 해당 캐시 데이터 유지

57. A,B > D,E
• 합성키, 여러 속성 값을 하나의 인공적인 partitionkey 속성으로 연결하여 파티션 키를 구성
• 작업 부하를 보다 균등하게 분산하는 또 다른 가능한 전략은 파티션 키 값 끝에 임의의 숫자를 추가하는 것으로, 해당 방식으로 항목을 배포하면 파티션 간에 병렬 쓰기 작업을 수행 가능함

58. y-y-y
1) container1,2 인스턴스 생성
2) 26,28행
3) 30행

59. 2-4-3-1 > 4-3-1-2
1) 모니터링되는 컨테이너에는 변경 피드가 생성되는 데이터가 있어 컨테이너에 대한 모든 삽입 및 업데이트는 컨테이너의 변경 피드에 반영됨.
2) 임대 컨테이너는 상태 저장소 역할을 하고 여러 작업자에 걸쳐 변경 피드 처리를 조정하며 모니터링되는 컨테이너와 동일한 계정 또는 별도의 계정에 저장할 수 있음
3) 호스트는 변경 피드 프로세서를 사용하여 변경을 수신 대기하는 애플리케이션 인스턴스로, 임대 구성이 동일한 여러 인스턴스를 병렬로 실행할 수 있지만 각 인스턴스에는 다른 인스턴스 이름이 있어야함.
4) 대리자는 변경 피드 프로세서가 읽는 각 변경 배치로 개발자가 수행하려는 작업을 정의하는 코드

60. 7-1-6 > 5-7-4
• AD 인스턴스(테넌트) 선택 > 앱 등록에서 새 등록 선택 > 새 애플리케이션 생성 및 이름 제공

61. B,C

62. A > C
• CosmosDB 운영자는 Azure Cosmos 계정, 데이터베이스 및 컨테이너를 프로비저닝 할 수 있으나 데이터에 액세스하거나 데이터 탐색기를 사용할 수 없음
A : Azure CosmosDB 계정을 관리할 수 있음
B : 주기적인 백업 사용 데이터베이스 또는 컨테이너에 대한 Azure Portal에 대한 복원 요청을 제출할 수 있음
D : Azure CosmosDB 계정 데이터를 읽을 수 있음

63. B
• AAD 애플리케이션의 매니페스트에서 'groupMembershipClaims' 옵션의 값을 모두로 설정함
64. A
• AAD 애플리케이션의 매니페스트에서 'groupMembershipClaims' 옵션의 값을 모두로 설정함
65. B > A
• AAD 애플리케이션의 매니페스트에서 'groupMembershipClaims' 옵션의 값을 모두로 설정함
• 애플리케이션에 필요한 권한 수준과 일치하는 애플리케이션 역할을 정의하는 것도 솔루션이 될 수 있음

66. 1-2 > 3-2
1) 일시삭제(soft delete) 가 활성화되면 삭제된 리소스로 표시된 리소스가 지정된 기간(기본 90일)동안 유지되어 삭제된 개체를 복구하는 메커니즘을 추가로 제공하여 기본적으로 삭제를 취소함
2) 제거보호(Purge protection)는 선택적 Keyvault 동작이며 기본적으로 사용하도록 설정되어 있지 않음, 일시 삭제가 활성된 후에만 해당 기능을 활성화할 수 있음
> 제거보호가 켜져 있으면 보관기간이 경과할 때까지 삭제된 상태의 볼트 또는 개체를 제거할 수 없고, 일시 삭제된 볼트 및 개체는 계속 복구할 수 있으므로 보존정책을 준수해야함

67. A,C ?? A,D??
• 기본인증을 사용하여 백엔드 서비스로 인증하는 방법(기본인증), 클라이언트 인증서를 사용하여 백엔드 서비스에 인증하는 방법(클라이언트 인증), API Mangement 서비스에 대한 관리 ID로 인증하는 방법(관리 ID로 인증) 존재
C : 인증서 인증은 http 인증 헤더를 보내지 않음
D : MS에서 제공하는 정책이 아님 ??


68. 5-4-2 > 5-4-4
1) 사용자 위장(user_impersonation) 범위는 사용자를 대신하여 토큰이 요청되고 있음을 나타냄 > Azure Storage는 애플리케이션이 사용자가 허용하는 모든 작업을 수행하도록 허용하는 
user_impersonation이라는 단일 위임 범위를 노출함
2-3) 등록된 앱의 권한을 위임함

69. 3-1-1 > 1-1-1
1~2) UseAuthentication, 사용자가 보안 리소스에 액세스할 수 있도록 허용하기 전에 사용자를 검증해야하는 기능을 구현 > 해당 인증 기능을 활성화나느 지정된 applicaitonBuilder에 
AuthenticationMiddleware를 추가하여 사용자를 확인하려면 인증 미들웨어를 사용하도록 함
3) UseAzureAppConfiguration 미들웨어를 추가하여 ASP.NET Core 웹앱이 계속 요청을 수신하는 동안 새로 고침에 등록된 구성 설정을 업데이트할 수 있고 기능 플래그를 사용하려면 Azure App Configuration 서비스를 사용해야 함. 웹앱을 다시 시작할 필요 없이 구성 설정을 새로 고치려면 'UseAzureAppConfiguration()'의 미들웨어를 사용할 수 있음

70. A
• KeyVault에서 비밀을 읽으려면 자격 증명 모음을 만들고 앱에 액세스할 수 있는 권한을 부여하여 Key Vault 빠른시작에 따라 Key Vault를 생성
• Keyvault 참조는 기본적으로 앱의 시스템 할당 ID를 사용하지만 사용자 할당 ID를 지정할 수 있고 이전에 만든 애플리케이션 ID에 대ㅐ Key Vault에 대한 액세스 정책을 만들어 이 정책에 대한 "Get" 비밀 권한을 활성화함

71. A
• 승인된 클라이언트는 Blob을 해독하는데 사용할 개인키를 갖게 되고, 다른 클라이언트가 이미 암호화된 Blob을 다운로드하려고 하면 개인 키가 없으면 Blob의 콘텐츠에 액세스할 수 없음
72. B
• 기본적으로 저장소가 암호화되어 있지만 콘텐츠를 암호화해야 하므로 다운로드할 때 권한이 없는 사람에게는 쓸모가 없음 > Azure Key vault 및 공개 키 암호화를 사용
73. B
• Key vault는 응용 프로그램 비밀,인증서 등을 안전하게 저장하고 접수 양식 및 기타 문서와 같은 응용 프로그램 데이터를 저장하지 않음

74. 2-3-1-4-2 > 2-3-1-4-1
• keyvault 생성 > key 생성 > VM 생성 > Disk Encryption 생성 > OS와 Data 모두 암호화

75. D > C
• Azure AD MSI(Managed Service Identity)는 코드에서 자격증명을 유지할 수 있도록 Azure 서비스에 인증하기 위한 자동으로 관리되는 ID를 코드에 제공함
• 관리 ID를 사용하여 백엔드 서비스로 인증하려면 인증 관리 ID 정책을 사용 > 해당 정책은 기본적으로 관리 ID를 사용하여 지정된 리소스에 액세스하기 위해 AAD에서 액세스 토큰을 얻고, 토큰을 성공적으로 얻은 후 정책은 Bearer 체계를 사용하여 Authorization 헤더의 토큰 값을 설정함.
A : 인증 기본 정책을 사용하여 기본 인증을 사용하는 백엔드 서비스로 인증하는 정책은 HTTP Authorization 헤더를 정책에 제공된 자격증명에 해당하는 값으로 효과적으로 설정함 > 자격증명을 보냄.
B : 익명은 인증이 전혀 되지 않음
C : 클라우드 서비스에 인증하려면 코드에 자격증명이 필요하지만 이러한 자격증명의 가시성을 최대한 제한하려고 함.

76. 5-3-2-4-1 > 5-3-2-1-4 
할당은 적절한 구독을 선택한 다음 스토리지 계정 키를 검색하고, 이 키를 key vault에 저장하고 마지막으로 비밀이 제대로 삽입 되었는지를 확인하는 과정
• 구독 list > 로깅할 자격증명모음과 연결된 구독 지정 > 해당 스토리지 계정 키를 가져옴 > 
비밀을 검색한 후 해당 키를 보안 문자열로 반환한 다음 자격 증명 모음에서 해당 값으로 비밀을 생성 > 생성한 암호의 URI를 가져오고 Key vault를 호출하고 비밀을 검색하기 위해 URI 사용

77. B
• Invoke-WebRequest cmdlet을 실행하여 Azure 리소스 끝점에 대한 로컬 관리 ID에 요청함
78. A > B
• Azure RBAC는 리소스에 대한 세분화된 액세스 관리를 제공하는 Azure Resource Manger에 구축된 권한 부여 시스템으로, 인증이 아닌 권한 부여에 사용됨
79. 1-3-4-1-3 > 1-1-4-4-1
1) Azure AD 조건부 액세스는 'Android','iOS','Windows Phone','Windows' 등으 플랫폼만 지원
2) 'DeliveryRulesDeviceConditionParameters'은 배달 규칙에 대한 IsDevice 조건을 정의함
3) 'HTTP_USER_AGENT'
4) 'DeliveryRuleRequestHeaderCondition'은 배달 규칙에 대한 RequestHeader 조건을 정의함
5) Azure AD 조건부 액세스는 'Android','iOS','Windows Phone','Windows' 등으 플랫폼만 지원

80. A > B
• Azure AD에서 애플리케이션을 만들고, 'groupMembershipClaims' 클레임을 설정하여 애플리케이션의 토큰을 검사하여 사용자가 해당 그룹의 일부인지 확인

81. A (77~78번과 같은 시나리오)

82. 2-2 > 2-4
• oauth2Permissions는 Boolean이 아닌 배열과 같은 컬렉션 값만 받아들일 수 있음
1) groupmembershipnClaim을 변경하여 그룹 구성원 자격 클레임을 활성화함
2) Boolean 필드이므로 'oauth2AllowIdTokenIplicitFlow'가 알맞음

83. B
• 일반적인 Blob 저장소 이벤트 시나리오에는 이미지 또는 비디오 처리, 검색 인덱싱 또는 모든 파일 지향 워크플로가 포함되는데, 비동기식 파일 업로드는 이벤트에 적합하고 변경이 드물지만 시나리오에 즉각적인 응답이 필요한 경우 이벤트 기반 아키텍처가 특히 효율적일 수 있음
• 'Start-AzureStorageBlobCopy' cmdlet은Blob 복사를 시작하여 Blob을 차단, 페이지 또는 추가하거나 기존 블록 Blob의 컨텐츠를 업데이트함.



84. A
• 단일경로 제거는 자산의 전체 경로(프로코톨 및 도메인 제외)를 지정하여 개별 자산을 제거함
ex. /pictures , /스트라스부르.png
• 와일드 카드 경로 제거는 별표(*)를 와일드카드로 사용하여 경로에 /*가 있는 끝점 아래의 모든 폴더, 하위 폴더 및 파일을 제거하거나 /*가 뒤에 오는 폴더를 지정하여 특정 폴더 아래의 모든 하위 폴더 및 파일을 제거함 ex. /pictures/*
• 루트 도메인 제거는 경로에 "/"가 있는 엔드포인트의 루트를 제거함.

85. C > D (75번과 같은 문제)
"귀사에서 Azure API를 개발 중입니다."라고 표시되는 문장으로 관리형 ID로는 맞춤형 API를 보호할 수 없음 

86. B > D
• 들어오는 모든 요청에 대해 OAuth 토큰의 유효성을 검사하는 validate-jwt 정책을 추가하는 솔루션
87. Inbound-Outbound-Inbound-Inbound > In-In-Out-Out
1) 사용자 요청에서 사용자 ID를 감지한 다음 캐시에 데이터를 저장해야하므로 이에 대한 수신 요청을 살펴봐야함
2) 사용자 데이터가 캐시에 이미 존재하지 않는지 화


88. 4-1
1) SecreClient
2) DefaultAzureCredential() 클래스를 사용하여 ID를 제공하기 위해 다른 옵션으로 다른 환경에서 동일한 코드를 사용할 수 있도록 함

89. A,C > A,B
• MS graph에서 Azure AD REST API를 사용하여 Azure AD 리소스와 타사 서비스간에 고유한 워크플로를 만들 수 있음 > 엔터프라이즈 개발자는 MS Graph를 사용하여 AAD ID 관리 및 기타 서비스를 통합하여 직원 온보딩 및 종료, 프로필 유지 관리, 라이선스 배포등과 같은 워크플로를 자동화함
• MSAL은 MS Graph에 대한 보안 액세스를 위한 것



90. A,C > A,D
• SAS가 손상되었다고 생각되면 SAS를 취소해야하는데 사용자 위임 키를 취소하거나 SAS를 만드는 데 사용된 보안 주체에 대한 RBAC 역할 할당을 변경 또는 제거하여 사용자 위임 SAS를 취소할 수 있음

91. 2-6-4-1
• KEK(키 교환 키)를 생성하고, 검색한 후, HSM 공급업체에서 제공하는 도구를 사용하여 키 전송 Blob 파일을 생성하고 'az keyvault key import' 명령을 실행하여 키 전송 blob을 업로드하여 HSM 키를 가져오는 과정

92. A
"Azure Logic 앱이 삭제된 경우 Azure AD의 리소스는 남아 있어야 합니다."
• 사용자 할당 키는 개별 구성 요소로, 논리 앱을 삭제해도 키는 남아 있음
• 시스템 할당 키의 경우는 자동 생성되어 Azure 리소스 자체가 삭제되면 자동 삭제됨.

93. y-y-y-y 
1) 60일 이상 수정되지 않은 컨테이너1/판매 주문 또는 컨테이너2/재고 앞에 있는 블록 블럽은 쿨 스토리지로 이동됩니다. 120일 동안 수정되지 않은 Blob은 아카이브 계층으로 이동됩니다.
2) 블롭은 30일 동안 액세스하지 않은 경우 쿨 스토리지로 이동합니다.
3) Blobs는 Cool로 계층화된 후 다시 접속하면 자동으로 Cool에서 Hot로 계층화됩니다..
4) 730일 보다 오래된 Block Blob은 삭제된다. ?? 
(문제는 dayAfterModificationGreaterThan:730)

94. A,C > C,D
• 변경 피드 사용을 막 시작하는 경우 Azure Functions가 가장 간단한 옵션으로 단순성으로 인해 대부분의 변경 피드 사용 사례에 권장되는 옵션임
• Azure CosmosDB에 대한 Azure Functions 트리거를 만들 때 연결할 컨테이너를 선택하면 컨테이너에 변경 사항이 있을 때마다 Azure Function이 트리거되어 백그라운드에서 변경 피드 프로세서를 사용하기 때문에 컨테이너 파티션에서 변경 처리를 자동으로 병렬화함



95. n-y-y > n-n-y
1) 시스템이 초과하지 않기를 바라는 최고 또는 최대 RU/s Tmax를 설정 , 
시스템은 0.1*Tmax <= T <= Tmax가 되도록 처리량 T를 자동으로 조정함
> 문제에서 T=5000 이므로, 컨테이너의 최소 처리량은 500R/U
2) 해당 쿼리는 파티션 키에 대한 범위 필터가 있고 ㄷㄴ일 물리적 파티션으로 범위가 지정되지 않는 쿼리로 파티션 내 쿼리가 되려면 쿼리에 파티션 키를 포함하는 동등 필터가 있어야함.
ex. select * from c where c.DeviceId > 'XMS-0001'
3) 동등필터가 존재하지만 UserId는 파티션 키가 아님

96. 4-2 > 1-1
1) 클라이언트 암호로 기빌 클라이언트 응용 프로그램을 인스턴화하는 코드 :
app=ConfidentialClientApplicationBuilder.Create(config.ClientId)
.WithClientSecret(config.ClientSecret)
.WithAuthority(new Uri(config.Authority))
.build();
2) 기밀 클라이언트 애플리케이션을 구성한 후 'AcquireTokenForClient'를 호출하고 범위를 전달하고 선택적으로 토큰 새로 고침을 강제 실행하여 앱에 대한 토큰을 얻을 수 있음
코드 : result = app.AcquireTokenForClient(scopes).ExecuteAsync();

97. B,C > B,D
• message.Properties.Add("ParentId" , operation.Telemetry.Id);
• message.Properties.Add("RootId" , operation.Telemetry.Context.Operation.Id);

98. n-y-n > y-n-y
1) MIME 형식은 서비스에서 지원됩니다.
> Front Door는 가장자리에서 콘텐츠를 동적으로 압축하여 클라이언트에 대한 응답을 더 작고 빠르게 할 수 있어 모든 파일은 압축할 수 있음 , 그러나 파일은 압축 목록에 적합한 MIME 유형이여야함.(MIME 유형은 application/xml 이 지원됨)
2) 모든 캐시 자산에서 에지 노드를 제거해야 합니다.
> 파일 크기가 8MB 미만이 아니므로 캐시 자산을 제거할 필요가 없음
3) 압축 유형이 지원됩니다.
> 이러한 프로필은 Gzip(GNU zip), Brotli와 같은 압축 인코딩을 지원함

99. 3-3-2 > 2-3-3
1) '재정의(override)'는 원본 제공 캐시 기간을 무시하는 대신 제공된 캐시 기간을 사용하여 
'cache-control:no-cache'를 재정의하지 않음
** '누락된 경우 설정(Set if missing)은 원본 제공 캐시 지시문 헤더가 있는 경우에만 존중함
   그렇지 않은 경우 캐시 기간을 사용
*** '캐시 우회(Bypass cache)'는 원본 제공 캐시 지시문 헤더를 캐시하지 않고 무시함
2) 모든 미디어 콘텐츠는 1시간 후에 캐시에서 만료되어야 함
3) 모든 고유 URL 캐시(Cache every unique URL) 모드에서 쿼리 문자열을 고유 URL이 있는 각 요청은 공한 캐시가 있는 고유 자산으로 처리됨.
ex. 'example.ashx?q=test1'에 대한 요청에 원본 서버의 응답은 POP 노드에서 캐시되고 동일한 쿼리 문자열을 사용하여 후속 캐시에 대해 반환됨. 'example.ashx?q=test2'에 대한 요청은 고유한 TTL 설정이 있는 별도의 자산으로 캐시됨.

100. 2-3-4-6


