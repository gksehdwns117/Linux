201. A
• Azure Pipelines를 사용하여 코드를 빌드하거나 소프트웨어를 배포하려면 하나 이상의 에이전트가 필요로하고 온프레미스 환경에 MS 호스팅 에이전트 풀에 대한 연결이 없는 경우 온프레미스 컴퓨터에서 자체 호스팅 에이전트를 수동으로 구성해야함. 
• 에이전트는 대상 온프레미스 환경에 연결해야 하고 인터넷에 액세스하여 Azure Pipelines 또는 Team Foundation Server에 연결해야함

202. C
• ACR(Azure Container Registry) 작업은 기본 이미지 중 하나에서 OS 또는 애플리케이션 프레임워크를 패치하는 경우와 같이 컨테이너의 기본 이미지가 업데이트될 때 자동화된 컨테이너 이미지빌드를 지원함

203. B (199~201번과 같은 시나리오)

204. B ?? (197~198번과 같은 시나리오)
• 중첩 템플릿은 고유한 리소스 그룹을 지원할 수 있어 중첩 템플릿을 구축하는 것은 구현을 위해 구축된 것이므로 템플릿 재사용을 쉽게 지원하지 않음
☞ 여기서 연결(linked) 템플릿을 사용하면 연결된 템플릿을 다른 용도로 다시 사용할 수 있으므로 최상의 솔루션임
205. A (197~198번과 같은 시나리오)

206. 2-4-3-5 > 3-1-2-4
2) 개발자는 'Azure Artifacts'를 사용하여 다양한 피드와 공용 레지스트리에서 패키지를 공유하고 사용할 수 있는데 패키지는 동일한 팀/조직내에서 공유할 수 있으며 공개적으로도 공유 가능
3) 파이프라인 보기에서 모든 단계 및 관련 테스트를 볼 수 있음(보기는 테스트 결과의 요약을 제공함)
4) MS는 자주 업데이트되는 대용량 바이너리에 원격 저장소를 사용할 것을 권장함
(Git LFS가 가장 적절한 솔루션) 

207. B
• 피드 '보기(views)'를 사용하면 피드에 있는 NuGet, npm, Maven, Python 패키지 버전의 하위 집합을 소비자와 공유할 수 있음
• 보기(views)의 일반적인 용도는 테스트, 검증, 배포된 패키지 버전을 공유하지만 아직 개발중인 패키지와 품질 기준을 충족하지 못한 패키지를 보류하는 것임

208. D
• 소프트웨어 종속성 및 운영체제를 더 많이 제어하려면 컨테이너 작업을 사용할 수 있음
☞ 컨테이너내에서 파이프라인을 실행할지 여부와 자체 호스팅 에이전트를 사용할지의 여부는 독립적인 것으로 자체 호스팅 에이전트 또는 컨테이너 내부에서 파이프라인을 직접 실행 가능
• 컨테이너 인스턴스는 비용 효율적이므로 두개의 작업을 만들어 충돌을 줄이는 것이 합리적인 솔루션

209. simulation

210. D
A : 사용자 추가는 자동화 작업이 가능

211. 3-4 > 2-3 RTW
1) TFS 데이터베이스를 마이그레이션하기 위한 주요 전제 조건 중 하나는 데이터베이스 스키마 버전을 현재 Azure DevOps Services에 배포된 버전과 최대한 비슷하게 만드는 것
2) 마이그레이션 프로젝트의 3단계에서는 Azure DevOps Services의 데이터베이스 가져오기 서비스에 대해 지원되는 버전 중의 하나로 Team Foundation Server를 업그레이드하는 작업을 수행함

======================= topic 7 : QuestionSet 7 =======================
212. 1-2 (4번과 같은 문제)
1) Liveness 설정은 실패하면 포드를 다시 시작하고, Readiness 설정은 포드를 시작하지 말고 서비스 로드 밸런서에서 제외됨, Startup 설정은 포드가 성공적으로 시작될때까지 위의 프로브를 비활성화함.
2) Probe Period (프로브 주기) > 1분에 4번 상태확인

213. 4-2 > 1-2
1) '--aggressive' 옵션은 git에서 불필요한 파일 정리 및 로컬 저장소를 최적화
2) 'prune' 옵션은 개체 데이터베이스에서 연결할 수 없는 모든 개체 정리

214~215. simulation
(215번 또 다른 문제 A)
216. 1-5-4 > 2-4-1
1) tiller 서비스 생성 및 클러스터 관리자 역할 바인딩
☞ $ kubectl create -f rolebinding-tiller.yaml
2) tiller(Helm 서버)를 안전하게 설치 측면 구성 요소
☞ $ helm init --service-accouttiller -tiller-namespacetiller-world
3) 차트(패키지) 설치
☞ $ helm install nginx --tiller-namespacetiler-world --namespacetiler-world

217. D
• Azure DevOps에 설치된 Labs 작업 확장을 사용하여 CI/CD 빌드 및 릴리스 파이프라인을 Azure DevTest Labs와 쉽게 통합 가능

218. 2-1-3 > 1-2-3
1) Private - App Center에서 메일 그룹은 기본적으로 비공개로 이메일을 통해 초대된 테스터만  그룹에서 사용할 수 있는 릴리스에 액세스 할 수 있음
2) Public - 공개 링크에서 인증되지 않은 설치를 사용하려면 메일 그룹을 공개해야함
3) Shared - 공유 메일 그룹은 단일 조직의 여러 앱에서 공유되는 개인 또는 공개 메일 그룹

219. simulation

220. 4-3-1
1) Azure FIles를 통하여 SMB 프로토콜을 사용하여 연결할 수 있음
2) Managed disk - Azure Disk
3) 현재 Key Valt FireVolume은 지원 중단됨 > Key vault Secrets

221. C
• Cherry-Pick은 분기의 모든 변경사항 대신 선택한 커밋의 변경 사항만 가져옴

222. 4-3-2 > 4-3-5 ***
• .gitgnore의 각 줄은 패턴과 일치하는 파일 또는 파일 집합을 제외함

223. B
자체 호스팅 에이전트를 해당 시나리오에 사용 가능하고 확장집합(VMSS)보다 저렴함 ??
ACI는 빌드 시간에 대해서만 비용을 지불함(보기 중 가장 저렴)
224. 4-4-1 > 4-1-4
• 대부분의 VCS와 마찬가지로 Git에는 리포지토리의 특정 지점을 중요한 것으로 태그 지정하는 
기능이 있어 일반적으로 해당 기능을 사용하여 릴리스 지점(v1.0,v2.0)을 표시함
• $ git tag -a <tag name> <commit_sha> -m "메시지"

225. A > C
• Visual Studio ARM 베포 프로젝트를 만들 때 배포 powershell 스크립트와 함께 제공되는 솔루션에 있는데 
powershell을 실행하여 최소한의 노력으로 리소스를 배포할 수 있음

226. 1-3 > 3-1 (63번과 비슷한 시나리오 - 비교)
1) 관리 평면 작업(생성/삭제/가져오기/검색/설정) 액세스 제어는 RBAC을 사용
2) 키, 비밀, 인증서를 제어하기 위한 키 자격증명모음 리소스 액세스 정책 사용

227. 3-1-5 > 3-5-1
• CI/CD를 위해 Azure Pipelines를 생성하고 ARM 템플릿과 통합 > Azure 리소스 그룹 배포 작업
을 추가 > 템플릿 매개변수 설정

228. A
리포지토리에 배포 상태 보고 이후 통합 옵션 수정 > 내부 통합 옵션 설정

229. simulation
230. D
• RBAC 지원 AKS 클러스터에 Helm을 배포하려면 먼저 Tiller 서비스에 대한 서비스 계정 및 역할
바인딩이 필요로함

231. simulation
232. 4-2 > 8-2 ***
1) Development,QA,Pre-Prod,Production,Stakeholder Review,Load Test,Internal Review
☞ 이미지의 박스 갯수 = 7개 ??
2) ?? 

233. 3-1 > 1-1
• 배포그룹은 각각에 에이전트가 설치된 배포 대상 머신의 논리적 집합
• Azure Pipelines 또는 TFS 릴리스 파이프라인을 작성할 때 배포 그룹을 사용하여 작업의 배포 
대상을 지정할 수 있는데 대상 머신이 Azure VM인 경우 각 VM에 Azure Pipelines 에이전트 
Azure VM 확장을 설치하거나 파이프라인에서 Azure 리소스 그룹 배포 작업을 사용하여 배포 그
룹을 동적으로 생성하여 쉽게 준비할 수 있음

234. B,C > C,D
• Terraform 모듈을 쉽게 만들기 위하여 Yeoman이 필요로함
• Yeoman을 설치하려면 Node.js가 필요로하고 Terratest는 테스트용으로 필요로하지만 Node.js가 
없으면 Yeoman을 설치할 수 없어 우선순위가 더 높음

235~236. simulation
237. 1-2-2 > 1-3-2
1) 소프트웨어 장애에 대한 허용오차별로 그룹화된 사용자가 릴리스에 참여 전략
☞ Progressive exposure 그룹은 새 릴리스를 사용하여 경험을 모니터링하는 사용자를 그룹화함
2) 앱의 이후 릴리스에서 사용할 수 있는 기능을 활성화하기 위해 코드 배포 전략
☞ Feature Flag는 고객 우선 DevOps 사고방식을 지원하여 솔루션의 기능이 완성되어 출시 준비
가 되기 전에 활성화(노출) 및 비활성화(숨기기)함
3) 새 릴리스가 발생하면 기존 배포가 활성 상태를 유지하여 이전 버전으로 돌아가야 하는 경우
복구 시간 최소화 전략
☞ Blue/Green 배포는 이전 버전(Blue)을 교체하는 대신 기존 버전 옆에 새버전(Green)을 불러와 
그린 버전이 제대로 작동하는지 성공적으로 검증하는 조건으로 다운타임 없이 라우팅 구성을 변
경하여 이 버전을 공개 버전으로 승격함

238. 2-1-4 > 2-4-5
• Azure 테스트 계획에서는 수동 테스트 사례만 추가할 수 있어 자동화된 테스트의 경우 선택한 
프로그래밍 언어로 테스트를 생성해야함
☞ 수동으로 테스트를 생성하고 Azure Repos에 생성한 테스트를 추가, 파이프라인에서 실행할 프
로젝트를 추가하는 과정

239. 1-6-4 > 2-6-4
• Docker Compose는 AKS용이 아님 > Helm은 k8s 클러스터의 변수를 매핑하는 템플릿
• RBAC 권한 구성은 서비스 주체에 대해 필요한 권한을 구성하기 위하여 필요로함
Azure AD 서비스 주체 생성 > RBAC 역할 구성 > Helm 패키지 추가

240. A > B
• 사후 및 사전 배포 게이트웨이에는 모두 시간 초과 설정이 있지만 배포 전에 조건을 확인해야 
하므로 post-gateway(배포 후)가 아닌 pre-deployment gateway(배포 전)
241. A ***
게이트 대신 사전 배포 승인 사용?? 게이트와 관련없음??
• Gates를 사용하면 외부 서비스에서 상태 신호를 자동으로 수집한 다음 모든 신호가 동시에 성
하면 릴리스를 승격하거나 시간 초과 시 배포를 중지 
• 일반적으로 게이트는 사고 관리, 문제 관리, 모니터링 및 외부 승인 시스템과 관련하여 사용되
어 승인 및 게이트를 통해 배포 파이프라인의 시작 및 완료를 추가로 제어할 수 있음
• 릴리스 파이프라인의 각 단계는 사용자가 수동으로 배포를 승인하거나 거부할 때까지 대기하고 
특정 조건이 확인될 때까지 다른 자동화 시스템과 확인하는 것을 포함할 수 있는 배포 전 배포 
후 조건으로 구성할 수 있음
242. A

243. 2-1
1) Canary 릴리스는 잠재적인 문제를 조기에 식별하는 방법으로 모든 사용자를 문제에 노출시키
지 않고 모든 사용자가 사용할 수 있도록 하기 전에 소수의 사용자에게만 새 기능을 노출
2) 빠르게 롤백하려면 Blue/Green 방법이 더 적절함
☞ 롤링 배포는 모든 서버에 한 번에 패키지를 배포하는 대신 각 서버에 하나씩 배포하여 릴리스
를 천천히 롤아웃하는 패턴

244. B (240~242번과 같은 시나리오)
배포 전 조건에서 사전 승인 옵션

245. 1-4-2-5 (192번과 비슷한 시나리오)
• VM을 온보딩하려면 Azure Automation 계정이 필요하고 DSC 구성을 노드에 할당하기 전에 DSC 구성을 
컴파일해야하고 컴파일 하기 전에 DSC 확장을 설치해야하고 DSC 확장을 설치하려면 Automation 계정 필요
• 계정 생성 > 온보딩 > 업로드 > 컴파일

246. B > C
병렬 작업으로 시간 단축
247. simulation

248. B
• DACPAC 및 BACPAC은 유사하지만 다른 시나리오를 대상으로 사용
☞ DACPAC은 기존 데이터베이스 업그레이드를 포함하여 스키마 캡처 및 배포에 중점을 두어 주
요 사용 사례는 밀접하게 정의된 스키마를 개발, 테스트 및 프로덕션 환경에 배포할 때 사용함
☞ BACPAC은 두 가지 주요 작업(Import/Export)을 지원하는 스키마 및 데이터 캡처에 중점을 두
는데 'Export' 작업은 스키마와 데이터베이스의 데이터를 BACPAC으로 보내는 작업이고 'Import' 
작업은 스키마와 데이터를 호스트 서버의 새 데이터베이스로 가져오는 작업

249. 1-2 > 2-3
1) 동적 ID가 있는 비밀을 참조, 현재 배포에 따라 달라지는 주요 자격 증명 모음 비밀을 참조
2) "TemplateLink"는 상위 템플릿에서 연결된 템플릿을 추가하고 동적으로 생성된 리소스 ID가 포
함된 매개변수를 전달함

250. B,D
• 웹사이트 릴리스는 각각 다른 빌드 파이프라인에서 두 빌드(아티팩트)의 특정 버전을 수집하여 
생성하는데 릴리스는 먼저 Dev 단계에 배포된 다음 병렬로 두개의 QA 단계로 분기됨. 두 QA 단
계에서 배포가 성공하면 릴리스가 Production 링에 배포, 각 프로덕션 링은 전세계 여러 위치에
배포된 동일한 여러 인스턴스를 의미

251. C > A
• 기능 플래그는 고객 우선 DevOps 사고 방식을 지원하여 솔루션의 기능이 완전하고 출시 준비
가 되기 전에 활성화(노출) 및 비활성화(숨기기)함
C : 분기 정책은 Git 워크플로의 중요한 부분이며 마스터 분기의 완료된 작업에서 진행 중인 작업
을 분리하거나 마스터 분기에 도달하기 전에 변경 빌드를 보장하는 시나리오에 적합

252. C > B
• App Center는 새 릴리스를 배포하거나 테스터 중 한 명이 새 장치를 등록할 때 자동화된 작
업을 시작하고 모든 장치가 Apple ID를 사용하여 개발자 포털에 등록되고 앱에서 사용되는 모든 
프로비저닝 프로필이 새장 ID와 기존 장치 ID로 생성됨

253. D,E > E,F
• 정식으로 등록하기 전에 테스트 과정에서는 사설 CA가 필요하지 않고(B x) 스토어에 등록하지 
않음(C x)
• 수동으로 테스트하려면 장치 ID를 등록하고 새 릴리스를 배포

254. B > A (252번과 유사한 시나리오 문제)
https://docs.microsoft.com/ko-kr/appcenter/distribution/auto-provisioning
• 개발자는 배포 시 Apple에서 요구하는대로 보안을 위해 앱에 서명해야함
• 앱 다시 서명은 iOS 앱을 특정 테스트 디바이스에 배포하려는 경우에만 적용됨.
C : 애플리케이션 빌드에 서명해야함
D : 장치 소유자를 추가할 필요가 없음

7-45. D,E
• 온프레미스 설치는 일반적으로 방화벽으로 보호되므로 타사 웹훅은 온프레미스 서버에 연결할 수 없음
☞ 해당 문제를 해결하기 위해 웹훅 대신 폴링을 사용하여 코드가 변경될 대 빌드를 트리거하는 외부 Git 
Repo 유형을 사용할 수 있음
B : 방화벽의 이유로 MS에서 호스팅하는 에이전트는 연결할 수 없음

7-46. 2-2
• Feature Branch(기능 분기)는 단일 배포보다 개발 수명이 더 길 가능성이 있는 새로운 기능이나 향상 기능
을 개발할 때 사용됨 ☞ 기능 분기가 언제 완료되든 상관없이 항상 마스터 분기로 다시 병합됨
======================= topic 8 : QuestionSet 8 ==============================
255. 2-3 > 4-2 *** #1 사례 연구
문제 ) 모바일 애플리케이션이 주식 가격 서비스를 호출하는 데 필요한 비밀을 저장할 수 있도록 클라우드 
서비스를 구성해야 합니다. 해결책에 무엇을 포함시켜야 합니까?
"직원들은 하나의 모바일 애플리케이션을 사용하고 다른 하나느 고객이 사용함"
"투자 계획 애플리케이션 제품군에는 다중 계층 웹 애플리케이션 1개와 iOS 모바일 애플리케이션 2개가 포
함됩니다"
"시스템이 업그레이드될 때까지 서비스는 HTTPS를 통한 기본인증만 지원함.
• 공개 또는 서명된 액세스에 사용할 수 있는 Blob 또는 컨테이너 리소스에 대한 요청이 아닌 한 저장소 서
비스에 대한 모든 요청은 권한이 부여되어야함 > 요청을 승인하는 한 가지 옵션은 공유키를 사용하는 것
• Azure Storage는 HTTP와 HTTPS 모두를 지원하지만 HTTPS를 사용하는 것이 좋음

256. C
• 주기 시간(Cycle Time)은 팀이 작업 항목에 대해 적극적으로 작업을 시작한 후 작업 항목을 완료하는데 걸
리는 시간을 측정 (Lead Time과 구분)
** 누적흐름도(Cumulative Flow Diagram)는 병목현상을 줄이기 위해 작업으 유동성을 나타내며 그래프의 영
역이 커질수록 병목 현상이 더 많이 발생함
** Burnup은 수행한 작업의 양을 나타내며 목표를 향해 상승함
** Burndown은 남은 작업량을 나타내고 번다운 라인은 작업을 얼마나 빨리 소진시키는지 알려줌

257. B
The Burnup widget measures the elapsed time from creation of work items to their completion.
• Lead Time은 작업 항목 생성부터 완료까지의 시간을 측정함(주기시간과 비슷함)

258. D ***
https://docs.microsoft.com/en-us/power-platform/admin/power-automate-licensing/buy-licenses
구매에 대한 지출은 자동화 할 수 없음 ??

259. D > B
• CI빌드는 코드가 유지 관리 및 보안 모두에 대한 모든 규칙을 따르고 있는지 확인하기 위해 정적 코드 분
석 테스트를 실행해야함

260. B
• 마이그레이션 프로젝트의 3단계에서는 TFS를 Azure DevOps Services의 데이터베이스 가져오기 서비스에 
대해 지원되는 버전 중 하나로 업그레이드하는 작업을 수행함

261. B > D
• 팀이 프로세스 개선을 위한 프레임워크와 감사 가능한 결정 기록이 필요한 보다 공식적인 프로젝트 방법
을 따를 때 CMMI는 요구사항, 변경요청, 위험 및 검토를 추적하는 기능을 제공

262. 문제없음
263. B
• ApplyAndMonitor 매개변수는 새 구성의 초기 적용 후 대상 노드가 원하는 상태에서 벗어나면 DSC는 불
일치를 로그에 보고하는 기능을 하며, DSC는 ApplyAndMonitor가 적용되기 전에 성공할 때까지 구성을 적용
하려고 시도함. ☞ 대신에 ApplyAndAutocorrect 옵션 사용
264. A
• ApplyAndAutocorrect 매개변수는 DSC가 모든 새 구성을 적용하도록 하고 새 구성을 처음 적용한 대상 노
드가 원하는 상태에서 벗어나면 DSC는 불일치를 로그에 보고한 다음 현재 구성을 다시 적용함

265. B > C (147번과 유사한 시나리오) ??
To compile an Internet Information Services (IIS) web application that runs docker, you should use a Default 
build agent pool
• 호스팅 풀은 MS 호스팅 에이전트 모음인 기본 제공풀을 의미

266. B > A,C 둘다 가능
• 빌드 파이프라인에서 코드 적용 범위 결과 게시 작업을 사용하여 Cobertura 또는 JaCoCo 형식의 빌드에
서 생성된 Azure Pipelines 또는 TFS에 코드 적용 범위 결과를 게시함
☞ JaCoCo(Java 코드 적용 범위) , Cobertura(스페인어 적용)

267. D
• 조건부 액세스를 사용하면 조건에 따라 클라우드 앱에 액세스하기 위한 자동화된 액세스 제어 결정을 구
현할 수 있음

268. A
• GitHub Enterprise는 자체 보안 환경에서 배포하고 관리할 수 있는 GitHub의 온프레미스 버전으로 개발자
는 인기 있는 IDE, 지속적 통합 도구, 수백개의 타사 앱 및 서비스를 지원하여 개발 프로세스 전반에 걸쳐 
자신이 좋아하는 도구를 사용할 수 있음

269. C > B,C 둘다 가능
• SonarQube는 코드의 개선 영역을 식별하는 데 사용할 수 있는 정적 분석기 세트로 이를 통해 프로젝트의
기술 부채를 분석하고 향후 이를 추적할 수 있음
☞ Maven 및 Gradle 빌드 작업을 사용하면 신규 또는 기존 Azure DevOps Services 빌드 작업에서 최소한의
설정으로 SonarQube 분석을 실행할 수 잇음

270. C > D (186번 참고)
When moving to Azure DevOps, JIRA must be replaced with the build pipelines Azure DevOps service.

271. D > C
• npm install 명령은 개발 환경(기본값)의 패키지 디렉토리 내에서 실행될 때 다른 종속성과 함께
devDependecies를 설치하여 'npm install --only=prod(--only=production)'를 사용해 NODE_ENV 환경 변수의 
값에 관계없이 devDependencies가 아닌 종속성만 설치함

272. A
• 분기 정책에 빌드 유효성 검사를 추가할 수 있음(분기 정책을 추가하고 빌드 검증 파이프라인 추가)
273. B
상태정책은 SonarQube 같은 것을 확인하는 데 사용
274. B
체크인정책은 Git이 아닌 TFS에만 적용이 가능함

275. C
• Git 프로젝트에서 코드를 검토하고 병합하기 위한 pull 요청을 생성하고 풀 리퀘스트를 사용하면 팀이 코
드를 검토하고 마스터 브런치에 병합하기 전에 변경사항에 대한 피드백을 제공할 수 있음
☞ 리베이스는 분기 변경을 기본으로 재설정하려는 것
		
276. D > A
• 빠르게 롤백하려면 Green/Blue가 적합한데, Red/Black도 같은 의미임(어떤 색을 써도 의미상 같음)

277. C
• Gates는 품질 검증, 통과율, 코드 적용 범위와 같은 빌드 아티팩트에 대한 테스트의 메트릭을 쿼리하고 필
요한 임계값 내에 있는 경우에만 배포하도록 하는 시나리오에 적절

278. B
279. B
280. A
• 빌드 또는 릴리스 파이프라인에서 Azure SQL DB 배포 작업을 위해 DACPAC을 사용하여 배포하거나 
SQLCMD를 사용하여 스크립트를 실행함
281. C
https://docs.microsoft.com/ko-kr/azure/devops/pipelines/release/deployment-groups/?view=azure-devops
To deploy an application to a number of Azure virtual machines, you should create a universal group.
• 배포 그룹은 각각에 에이전트가 설치된 배포 대상 머신의 논리적 세트

282. B
• 피드에는 소유자, 기여자, 공동 작업자 및 독자의 4가지 수준의 액세스 권한이 있음
☞ 소유자는 모든 유형의 ID를 모든 액세스 수준에 추가할 수 있어 많은 권한을 가지고 있음
☞ 기여자 역할은 패키지 삭제/수정과 같은 권한은 제한되어 있어 해당 솔루션에 알맞음
283. B
284. A

285. B
• 피드 보기(view)를 사용하면 패키지 버전의 하위 집합을 소비자와 공유할 수 있고 피드 보기의 일반적인 
용도는 테스트하고 유효성을 검사하지만 아직 개발 중인 패키지를 공유하는 것이며 품질 그래프를 충족하지 
않는 패키지 버전을 공유하는것
• 업스트림 소스는 피드 보기와 같이 사용하지만 배포 단계에서의 공유할 때 사용함

286. C
To find when common open source libraries are added to the code base, you should add Jenkins to the
build pipeline.
• WhiteSource는 백그라운드에서 지속적으로 작동하여 업데이트되는 오픈 소스 리포지토리의 최종 데이터베
이스에 대해 오픈 소스 구성 요소의 보안, 라이선스, 품질을 확인함

287. A
빌드단계에서의 WhiteSource 배포 솔루션

288. A
Black Duck can be used to make sure that all the open source libraries conform to your company's licensing 
criteria.
• Black Duck은 조직이 애플리케이션 및 컨테이너 포트폴리오 전반에 걸쳐 오픈 소스 보안, 라이선스 규정 
준수 및 코드 품질 위험을 식별하고 완화할수 있도록 지원함

289. A,B ?? A,C ??
DSC 확장은 Azure Automation이 필요로 하므로 .. ??

290. B
291. B
292. A
• Helm 패키지 및 배포 작업을 사용하여 앱을 패키징하고 k8s 클러스터에 배포할 수 있는데 이 작업을 사
용하여 Tiller를 k8s 네임스페이스에 설치/업데이트하고 차트 배포를 위해 TLS를 통해 Tiller에 안전하게 연결
하거나 lint와 같은 Helm 명령을 실행할 수 있음

293. C
• 분기에서 생성된 빌드에 서명하려면 구성 창에서 코드 서명을 활성화하고 인증서 암호와 함께 프로비저닝 
프로필(.mobileprovision) 및 유효한 인증서(.p12)를 업로드함


294. D
• Azure Security Center는 모니터링하는 각 VM/컴퓨터, 웹 및 작업자 역할등에 대한 권장사항 집합과 영향
을 받는 리소스의 수, 문제의 심각도를 보여줌

295. B
To pinpoint the average load times of the application pages, you should make use of Azure Event Hubs.
• Application Insights는 웹 페이지와 iOS,Android,Widow 앱을 비롯한 다양한 장치에서 원격 분석 수행

296. A > C
• ITSMC(IT서비스관리커넥터)를 사용하면 Azure와 지원되는 ITSM 도구/제품을 연결할 수 있음
☞ ITSM 도구 : Service Now, System Center Service Manager, Provance, Cherwell

297. B
298. B
CQL, Transact-SQL, 
299. B
Log Analytics 자체로는 쿼리언어라고 보기 힘듦

300. D
301. A ??
모바일 앱에 관한 것으로 답은 App Center(Visual Studio App Center)여야함

